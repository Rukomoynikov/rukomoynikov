---
import Layout from "@layouts/Layout.astro";
import Container from "@components/Container.astro";
import InlineCode from "@components/InlineCode.astro";
import CodeSnippet from "@components/CodeSnippet.astro";
import TwoColsContainer from "@components/TwoColsContainer.astro";
import Video from "@components/Video.astro";
import Paragraph from "@components/Paragraph.astro";
import LinksList from "@components/LinksList.astro";
import Title from "@components/Title.astro";
import HeroTitleSmall from "@components/HeroTitleSmall.astro";
import { Code } from "astro/components";

import SocialIcon from "@assets/images/posts/elixir-telegram-bot/facebook-share.jpg";

const seo = {
  title: "How to make a Telegram bot in Elixir",
  description:
    "This is the first part of three in the series. There you will find creating foundation and answering to users.",
  socialImage: SocialIcon,
};
---

<Layout
  title={seo.title}
  description={seo.description}
  socialImage={seo.socialImage}
>
  <HeroTitleSmall title={seo.title} tags={["Telegram", "Elixir"]} />
  <Container>
    <Title level="2">Introduction to Telegram Bots API</Title>

    <Title level="3">Exchanging messages with Telegram</Title>

    <TwoColsContainer>
      <Paragraph>
        Telegram supports two types of integration: webhooks and polling.
        Webhooks it's a type when Telegram sends request to your server whenever
        bot recevied a message from the user. There pros and cons of that type
        of integration. Webhooks are more sustainable in general. For webhooks
        it's necessary to have web-server with external IP adress. This server
        will receive new messages through get requests from Telegram. During
        development you can use ngrock.
      </Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph>
        Polling is a constant polling of the Telegram server for new messages.
        For polling, you do not need a server and an external address. Simple
        application that sends requests to the Telegram server without stopping
        is enough.
      </Paragraph>
      <Fragment slot="aside">
        <LinksList
          links={[
            [
              "Documentation about Telegram bots",
              "https://core.telegram.org/bots/api#getting-updates",
            ],
          ]}
        />
      </Fragment>
    </TwoColsContainer>

    <Title level="3">Obtaining a token from Telegram</Title>

    <TwoColsContainer>
      <Paragraph>
        The token for Telegram requests must be obtained from the BotFather bot.
      </Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <Video src={"/videos/posts/elixir-telegram-bot/api_token.mp4"} />
      <Fragment slot="aside">
        <LinksList links={[["BotFather", "https://t.me/botfather"]]} />
      </Fragment>
    </TwoColsContainer>

    <Title level="2">Elixir</Title>

    <TwoColsContainer>
      <Paragraph>
        Elixir is a functional programming language. Based on the another
        programming language Erlang. The main advantage of Elixir is the ability
        to manage a huge number of processes. These processes are also made in a
        special way, so they take up significantly less memory and processor
        time than normal computer processes.
      </Paragraph>
      <Fragment slot="aside">
        <LinksList
          links={[
            [
              "How to install Elixir one elixir-lang.org",
              "https://elixir-lang.org/install.html",
            ],
            [
              "Installing with asdf package manager",
              "https://gist.github.com/mikoscz/4d2a0052d4cdaaa027bc8a8d6af1e817",
            ],
          ]}
        />
      </Fragment>
    </TwoColsContainer>

    <Title level="2">The application</Title>

    <TwoColsContainer>
      <Paragraph>
        I will gradually complicate the application. I'll start with a echo bot
        that sends a message back in response to a message. Next, I will add
        saving users to the database. And in the end, I'll try to make it a
        little useful - upon request from the user, the bot will send summary
        information about the stock market.
      </Paragraph>
    </TwoColsContainer>

    <Title level="3"
      >Creation of the skeleton of the application and installation of the
      necessary tools</Title
    >

    <TwoColsContainer>
      <CodeSnippet>mix new stocks_bot --sup</CodeSnippet>
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph>
        First you need to create a new application. The <InlineCode
          >--sup</InlineCode
        > option adds a supervisor to the application and starts it at startup. After
        creation, the structure of the application should look like this:
      </Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <CodeSnippet>
        ├── README.md ├── lib │ ├── stocks_bot │ │ └── application.ex │ └──
        stocks_bot.ex ├── mix.exs └── test ├── stocks_bot_test.exs └──
        test_helper.exs
      </CodeSnippet>
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph>
        Additionally, you need to install HTTPoison to send requests and Jason
        to work with JSON in responses from the Telegram server.
      </Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <CodeSnippet
        fileName={"stocks_bot/mix.exs"}
        lang={"elixir"}
        code={`
...

defp deps do
  [
    {:httpoison, "~> 1.8"},
    {:jason, "~> 1.2"}
  ]
end
      `}
      />
    </TwoColsContainer>

    <Title level="3">Receiving user message</Title>

    <TwoColsContainer>
      <CodeSnippet
        fileName={"stocks_bot/lib/stocks_bot.ex"}
        lang="elixir"
        code={`
defmodule StocksBot do
  @basic_url "https://api.telegram.org/bot<Токен от Botfather>

  def get_updates(offset \\ nil) do
    with {:ok, %HTTPoison.Response{status_code: 200, body: body}} =
           updates_url(offset) |> HTTPoison.get(),
         {:ok, data} = Jason.decode(body) do
      IO.inspect(data["result"])
    end
  end

  defp updates_url(_offset = nil) do
    @basic_url <> "getUpdates"
  end
end
      `}
      />
      <Fragment slot="aside">
        <LinksList
          links={[
            [
              "Documentation about Telegram bots",
              "https://core.telegram.org/bots/api#getting-updates",
            ],
          ]}
        />
      </Fragment>
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph>
        Now you can try how it works. Send your bot a message. Then open your
        terminal and enter these commands.
      </Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <CodeSnippet fileName="Terminal" icon="console">
        iex -S mix StocksBot.get_updates()
      </CodeSnippet>
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph>In the terminal you will see incoming message:</Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <CodeSnippet
        lang="elixir"
        code={`
[
  %{
    "message" => %{
      "chat" => %{
        "first_name" => "Bender",
        "id" => 300011235,
        "last_name" => "Rodriguez",
        "type" => "private",
        "username" => "bender"
      },
      "date" => 1636549063,
      "from" => %{
        "first_name" => "Bender",
        "id" => 300011235,,
        "is_bot" => false,
        "language_code" => "ru",
        "last_name" => "Rodriguez",
        "username" => "bender"
      },
      "message_id" => 1142,
      "text" => "Hello"
    },
    "update_id" => 475896056
  }
]
      `}
      />
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph>
        If you try to receive messages again, the answer will be the same. This
        happens because it is necessary to indicate to the telegram which
        messages have already been received. To do this, take the <InlineCode
          >update_id</InlineCode
        > of the last message, increase it to one and use it as a get parameter to
        receive new messages.
      </Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph
        >So far, the script receives one message and stops working, but it needs
        to continue listening to new messages. I'll fix it now.
      </Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <CodeSnippet
        fileName={"stocks_bot/lib/stocks_bot.ex"}
        lang="elixir"
        code={`
defmodule StocksBot do
  @basic_url "https://api.telegram.org/bot<Токен от Botfather>

  def get_updates(offset \\ nil) do
    with {:ok, %HTTPoison.Response{status_code: 200, body: body}} =
           updates_url(offset) |> HTTPoison.get(),
         {:ok, data} = Jason.decode(body) do

      parse_messages(data["result"])
      |> get_last_update_id()
      |> get_updates()
    end
  end

  defp parse_messages(messages) do
    Enum.each(messages, fn message ->
      IO.inspect(message)
    end)

    messages
  end

  defp get_last_update_id(_messages = []) do
    nil
  end

  defp get_last_update_id(messages) do
    List.last(messages) |> Map.fetch!("update_id")
  end

  defp updates_url(_offset = nil) do
    @basic_url <> "getUpdates"
  end

  defp updates_url(offset) do
    @basic_url <> "getUpdates?offset=#{offset + 1}"
  end
end
      `}
      />
    </TwoColsContainer>

    <Title level="3">Polite answer</Title>

    <TwoColsContainer>
      <CodeSnippet
        fileName={"stocks_bot/lib/stocks_bot.ex"}
        lang="elixir"
        code={`
...

defp parse_messages(messages) do
  Enum.each(messages, fn message ->
    answer_to_message(message)
  end)

  messages
end

defp answer_to_message(message) do
  %{
    "message" => %{
      "chat" => %{"id" => chat_id},
      "text" => original_text
    }
  } = message

  answer = %{
    text: "Hello: #{original_text}",
    chat_id: chat_id
  }

  HTTPoison.post(
    @basic_url <> "sendMessage",
    Jason.encode!(answer),
    [{"Content-Type", "application/json"}]
  )
end
        `}
      />
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph
        >The <InlineCode>answer_to_message</InlineCode> function uses pattern matching
        to pick up the sender's name and the text of the incoming message to send
        it back to the user as a post-request.
      </Paragraph>
    </TwoColsContainer>

    <Title level="3">Using supervisor for the application</Title>

    <TwoColsContainer>
      <Paragraph>First step is converting app to a Genserver.</Paragraph>
    </TwoColsContainer>

    <TwoColsContainer>
      <CodeSnippet
        fileName={"stocks_bot/lib/stocks_bot.ex"}
        lang="elixir"
        code={`
defmodule StocksBot do
  use GenServer
  @basic_url "https://api.telegram.org/bot<Токен от Botfather>

  def start_link(args) do
    GenServer.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  @impl true
  def init(:ok) do
    get_updates()
    {:ok, %{}}
  end

...
        `}
      />
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph
        >Then this Genserver need to be added to Supervisor Tree.</Paragraph
      >
    </TwoColsContainer>

    <TwoColsContainer>
      <CodeSnippet
        fileName={"stocks_bot/lib/stocks_bot/application.ex"}
        lang="elixir"
        code={`
defmodule StocksBot.Application do
  use Application

  @impl true
  def start(_type, _args) do
    children = [ StocksBot ]

    opts = [strategy: :one_for_one, name: StocksBot.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
        `}
      />
      <Fragment slot="aside">
        <LinksList
          links={[
            [
              "Article from AppSignal with good examples",
              "https://blog.appsignal.com/2021/08/23/using-supervisors-to-organize-your-elixir-application.html",
            ],
          ]}
        />
      </Fragment>
    </TwoColsContainer>

    <Title level="2">Demo time</Title>

    <TwoColsContainer>
      <Video src={"/videos/posts/elixir-telegram-bot/demo_of_bot.mp4"} />
    </TwoColsContainer>

    <TwoColsContainer>
      <Paragraph
        >Yes, the bot does not yet have superintelligence. In the next part, I
        will add user storage in the database and teach the bot to send stock
        price information.</Paragraph
      >
    </TwoColsContainer>
  </Container>
</Layout>
