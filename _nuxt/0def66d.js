(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{556:function(e,t,n){var content=n(584);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,n(42).default)("2cd0a1bd",content,!0,{sourceMap:!1})},583:function(e,t,n){"use strict";n(556)},584:function(e,t,n){var o=n(41)(!1);o.push([e.i,"\n.article-layout {\n  display: flex;\n}\n@media only screen and (max-width: 595px) {\n.article-layout {\n    flex-direction: column;\n}\n}\n.article-layout__text {\n  display: flex;\n  margin-right: 42px;\n}\n.article-layout__quotes {\n  display: flex;\n  font-size: 15px;\n}\n",""]),e.exports=o},599:function(e,t,n){"use strict";n.r(t);var o=n(1),l=n.n(o),r=n(495),c=n(510),d=n(471),v=n(467),h=n(472),y=n(415),m=n(480),f=n(532),_=n(561),k=n(562),w=l.a.extend({components:{HeroTitleSmall:r.default,CodeSinppet:c.default,LinksList:d.default,Title:v.default,Paragraph:h.default,Container:y.default,Spacing:m.default,CSDockerCompose:_.a,CSDockerfile:k.a,WithImage:f.default}}),C=(n(583),n(40)),component=Object(C.a)(w,(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div",[o("SocialHead",{attrs:{title:"How to generate Rails app and run it without installing ruby locally",description:"Docker image for generation rails application or play with ruby",image:n(418)}}),e._v(" "),o("HeroTitleSmall",{attrs:{tags:["Ruby","Docker"],title:"How to generate Rails app and run it without installing ruby locally",subtitle:"In internet plenty of articles about Dockerizing existing application. But, what if you don't have installed ruby locally and need to generate new app."}}),e._v(" "),o("Container",{attrs:{type:"common"}},[o("Title",{attrs:{level:2}},[e._v("\n      Why Docker?\n    ")]),e._v(" "),o("section",[o("Container",{attrs:{type:"content"}},[o("Paragraph",[e._v("\n          It has always been easier to supply the necessary tools locally. If you need to have multiple versions, then rvm or nvm solve the problem. Then came Docker. Until this year, I had successfully managed to avoid it. On projects where the guys worked with Docker, I instead installed everything locally. But, I thought that enough fighting and it's time to try to live with the idea of \"docker for everything\". It's simply time to admit either i work using Docker or i don't work at all.\n        ")])],1)],1),e._v(" "),o("Spacing",{attrs:{type:"vertical-section_sub"}}),e._v(" "),o("Title",{attrs:{level:2}},[e._v("\n      Generating Ruby on Rails application\n    ")]),e._v(" "),o("section",[o("Container",{attrs:{type:"content"}},[o("Paragraph",[e._v("\n          Well I don't have ruby installed locally. And I need to generate a new Rails application or experiment in IRB.\n        ")]),e._v(" "),o("Paragraph",[e._v("\n          The first thing I did was look at the official Rails image. It turned out to be deprecated, and the authors suggested Ruby as a replacement. Using Ruby image, I was unable to generate a Rails application, so I made my own Docker image.\n        ")]),e._v(" "),o("CodeSinppet",[o("CSDockerfile")],1),e._v(" "),o("LinksList",{attrs:{links:[["hub.docker.com/repository/docker/rukomoynikov/rails","https://hub.docker.com/repository/docker/rukomoynikov/rails/general"]]}})],1)],1),e._v(" "),o("Spacing",{attrs:{type:"vertical-section_sub"}}),e._v(" "),o("section",[o("Container",{attrs:{type:"content"}},[o("Title",{attrs:{level:3}},[e._v("\n          Using the image\n        ")]),e._v(" "),o("Paragraph",[e._v("\n          The following command will generate a new Rails application in the current folder and install required gems in the gems folder. As you know, a container cannot change its content after it has been built. Therefore, all application files and gems will be stored on the host machine.\n        ")]),e._v(" "),o("CodeSinppet",[e._v("docker run --rm -v /$(pwd):/app rukomoynikov/rails rails new .")]),e._v(" "),o("Paragraph",[e._v("\n          Launching the application is not much more difficult. But, in a simple form, it will only work if you use the sqlite database.\n        ")]),e._v(" "),o("CodeSinppet",[e._v("docker run --rm -it -p 3000:3000 -v /$(pwd):/app rukomoynikov/rails rails s -b 0.0.0.0")]),e._v(" "),o("Paragraph",[e._v("\n          Running IRB. Or you can enter console and run ruby files from local machine.\n        ")]),e._v(" "),o("CodeSinppet",[e._v("docker run --rm -it -p 3000:3000 -v /$(pwd):/app rukomoynikov/rails bash")]),e._v(" "),o("WithImage",{attrs:{image:"posts/rails-on-docker/rails-basic-app/rails-basic-app"}},[e._v("\n          Ruby on Rails default page\n        ")])],1)],1),e._v(" "),o("Spacing",{attrs:{type:"vertical-section_sub"}}),e._v(" "),o("Title",{attrs:{level:2}},[e._v("\n      What's next?\n    ")]),e._v(" "),o("section",[o("div",{staticClass:"article-layout"},[o("div",{staticClass:"article-layout__text"},[o("Container",{attrs:{type:"content"}},[o("Paragraph",[e._v("\n              Above you saw an example of basic Rails application used SQLite. In order to use Postgresql and Webpacker you need something more complicated than simple Dockerfile. You need docker-compose. There you will be able to separate application into a ruby service, and the client service.\n            ")]),e._v(" "),o("Paragraph",[e._v("\n              Here is example of docker-compose.yml\n            ")]),e._v(" "),o("CodeSinppet",[o("CSDockerCompose")],1)],1)],1),e._v(" "),o("div",{staticClass:"article-layout__quotes"},[o("LinksList",{attrs:{links:[["Heavily inspired by Evil Martians article","https://evilmartians.com/chronicles/ruby-on-whales-docker-for-ruby-rails-development"]]}})],1)])])],1)],1)}),[],!1,null,null,null);t.default=component.exports;installComponents(component,{SocialHead:n(416).default,HeroTitleSmall:n(495).default,Title:n(467).default,Paragraph:n(472).default,Container:n(415).default,Spacing:n(480).default,CodeSinppet:n(510).default,LinksList:n(471).default})}}]);